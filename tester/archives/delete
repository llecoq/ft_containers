

 		//	__parent_pointer __parent;
		// 	__node_base_pointer __dummy;
		// 	__node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __k);
		// 	__node_pointer __r = static_cast<__node_pointer>(__child);
		// 	if (__child == nullptr)
		// 	{
		// #ifndef _LIBCPP_CXX03_LANG
		// 		__node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);
		// #else
		// 		__node_holder __h = __construct_node(__args);
		// #endif
		// 		__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
		// 		__r = __h.release();
		// 	}

// Next do O(log N) search.
// Set __parent to parent of null leaf
// Return reference to null leaf
// If __v exists, set parent to node of __v and return reference to node of __v
// template <class _Tp, class _Compare, class _Allocator>
		// template <class _Key>
		// typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
		// __tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,
		//                                                 __parent_pointer& __parent,
		//                                                 __node_base_pointer& __dummy,
		//                                                 const _Key& __v)
		// {
		//     if (__hint == end() || value_comp()(__v, *__hint))  // check before
		//     {
		//         // __v < *__hint
		//         const_iterator __prior = __hint;
		//         if (__prior == begin() || value_comp()(*--__prior, __v))
		//         {
		//             // *prev(__hint) < __v < *__hint
		//             if (__hint.__ptr_->__left_ == nullptr)
		//             {
		//                 __parent = static_cast<__parent_pointer>(__hint.__ptr_);
		//                 return __parent->__left_;
		//             }
		//             else
		//             {
		//                 __parent = static_cast<__parent_pointer>(__prior.__ptr_);
		//                 return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
		//             }
		//         }
		//         // __v <= *prev(__hint)
		//         return __find_equal(__parent, __v);
		//     }
		//     else if (value_comp()(*__hint, __v))  // check after
		//     {
		//         // *__hint < __v
		//         const_iterator __next = _VSTD::next(__hint);
		//         if (__next == end() || value_comp()(__v, *__next))
		//         {
		//             // *__hint < __v < *_VSTD::next(__hint)
		//             if (__hint.__get_np()->__right_ == nullptr)
		//             {
		//                 __parent = static_cast<__parent_pointer>(__hint.__ptr_);
		//                 return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;
		//             }
		//             else
		//             {
		//                 __parent = static_cast<__parent_pointer>(__next.__ptr_);
		//                 return __parent->__left_;
		//             }
		//         }
		//         // *next(__hint) <= __v
		//         return __find_equal(__parent, __v);
		//     }
		//     // else __v == *__hint
		//     __parent = static_cast<__parent_pointer>(__hint.__ptr_);
		//     __dummy = static_cast<__node_base_pointer>(__hint.__ptr_);
		//     return __dummy;
		// }
		// 	return iterator(__r);
			// }
			// upper_bound++;
			// if (position == end() && lower_bound)
			// To insert x at p:
			// if p == end || x <= *p
			// if p == begin || x >= *(p-1)
			// insert x before p
			// else
			// insert x without hint
			// else if p+1 == end || x <= *(p+1)
			// insert x after p
			// else
			// insert x without hint